+++
weight = 40210
title = 'MB85RC256V FRAM memory I2C'
+++  

![alt text](/images/docs/mb85rc256v/image.png)

FRAM (ferroelectric RAM) is a non-volatile memory that combines the speed of SRAM with the persistence of EEPROM. It's pretty new and much more expensive than EEPROM or flash, but check out these benefits:
- Does not require a power supply to retain data
- Writes are "instant", no need to poll until the write is complete
- 10^12 write cycles, **1 million** times more than EEPROM
- 200uA operating current vs 1mA for EEPROM
- **Page size is the entire chip**, no juggling 8, 16 or 64 byte write pages!

The Fujitsu [MB85RC256V](https://www.fujitsu.com/uk/Images/MB85RC256V-20171207.pdf) is a 256Kbit (32Kbyte) FRAM memory chip with an I2C interface.

{{% readfile "/_common/_footer/_footer-cart.md" %}}

## Connections

|Bus Pirate|MB85RC256V|Description|
|-|-|-|
|IO0/SDA|SDA (5)|I2C Data|
|IO1/SCL|SCL (6)|I2C Clock|
|Vout|VDD (8)|3.3 volt power supply|
|GND|VSS (4)|Ground|

Connect the Bus Pirate to the FRAM as shown in the table above. 

![alt text](/images/docs/mb85rc256v/image-10.png)

In addition to the I2C and power connections, the MB85RC256V three address pins and a write protect pin (protection active when WP is high/1).

The base I2C address is 0b1010, while A0, A1 and A2 set the lower 3 bits of the address. To use multiple chips on the same I2C bus, connect one or more of the address pins to VDD to give each a unique I2C address.

{{% alert context="info" %}}
**The address and write protect pins have internal pull-down resistors**. By default the I2C address is 0b1010```000```, and write protection is **disabled**. Fujitsu was so considerate to include internal pull-downs on the pins, we don't need to set them with external components!
{{% /alert %}}

## See it in action

{{< asciicast src="/screencast/mb85rc256v-cast.json" poster="npt:0:31"  idleTimeLimit=2 >}}

## Setup

{{< termfile source="static/snippets/mb85rc256v-setup.html" >}}

This particular FRAM chip has an [I2C interface]({{< relref "/docs/command-reference/#i2c" >}}) with a top speed of 1MHz, though others have an [SPI interface]({{< relref "/docs/command-reference/#spi">}}) with a higher top speed.

- ```m i2c``` - change to [**I2C**]({{< relref "/docs/command-reference/#i2c" >}}) [mode]({{< relref "/docs/command-reference/#m-set-bus-mode" >}}).
- ```400``` - configure I2C for **400kHz**.
- ```1``` - disable clock stretching.

{{% alert context="info" %}}
While the FRAM has a top speed of 1MHz, 400kHz is more reliable when the device is connected to a breadboard or long wires. 
{{% /alert %}}


### Power supply

![alt text](/images/docs/mb85rc256v/image-1.png)

Despite being a modern chip, the FRAM still has a maximum supply of up to 5 volts. This is probably part of making it a drop-in replacement for the older EEPROMs.

{{< termfile source="static/snippets/mb85rc256v-power.html" >}}

Any voltage between 2.7 and 5.5 volts is acceptable. Let's go with the present standard of 3.3 volts. 

- ```W 3.3``` - enable the [onboard power supply]({{< relref "/docs/command-reference/#ww-power-supply-offon" >}}) at 3.3 volts.

Images source: [datasheet](https://www.fujitsu.com/uk/Images/MB85RC256V-20171207.pdf).

### Pull-up resistors
{{< termfile source="static/snippets/mb85rc256v-pullup.html" >}}

I2C is an open collector output bus, the Bus Pirate and the FRAM can only pull the line low to 0 (ground). A pull-up resistor is needed to pull the line high to 1 (3.3 volts). The Bus Pirate has built-in pull-up resistors that can be enabled with the ```P``` command.
- ```P``` - Enable the [onboard pull-up resistors]({{< relref "/docs/command-reference/#pp-pull-up-resistors">}}).

{{% alert context="warning" %}} 
Be sure to enable the pull-up resistors. The data line will never go high without them and you'll read only 0s.
{{% /alert %}}

## I2C address scan 

{{< termfile source="static/snippets/mb85rc256v-scan.html" >}}

Let's see if we can find the FRAM I2C address. We could look in the datasheet, or we can be lazy and run an I2C [address scan]({{< relref "/docs/command-reference/#scan-i2c-address-search">}}). 
- ```scan``` - Scan the I2C bus for devices

The scanner found an I2C device at address 0x50 (0xA0 write, 0xA1 read). That's the FRAM main interface. The second write address 0x7c (0xf8 write) is used to get the device ID, which we'll do later.

{{% alert context="info" %}} 
If the scanner doesn't find the device, ensure the power supply is enabled ```W 3.3``` and the pull-up resistors are enabled ```P```. 
{{% /alert %}}

## Write & Read Bytes

FRAM can read and write single bytes of data anywhere in the 32 Kbyte memory range. 

### Write Byte

![alt text](/images/docs/mb85rc256v/image-2.png)

Writing to the FRAM is identical to writing a [24Cxxx EEPROM]({{< relref "/docs/devices/24c02/" >}}). The write sequence is as follows:

1. I2C START bit - begins an I2C transaction
2. The I2C write address 0xA0 (Device Address + Write bit)
3. Two byte address of the location to write in the 32 Kbytes of FRAM
4. The data to write
5. I2C STOP bit - ends the transaction

{{% alert context="info" %}}
The address is two bytes representing a location from 0 to 32767 (0x0000 to 0x7FFF) in the memory array. The first byte is the high byte, the second byte is the low byte. 
{{% /alert %}}

{{< termfile source="static/snippets/mb85rc256v-write-byte.html" >}}

Let's write byte ```0x48``` to the FRAM at address 0x0009 (9). The address is two bytes, so we send ```0x00 0x09``` for the high and low bytes.
- ```[``` - [I2C START bit]({{< relref "/docs/command-reference/#bus-commands-4">}})
- ```0xa0``` - I2C address and write bit
- ```0x00 0x09``` - Set write location to address 0x0009 (9)
- ```0x48``` - Data to write
- ```]``` - I2C STOP bit

{{% alert context="info" %}}
Unlike EEPROM and flash memory, FRAM does not require a write delay. The write is "instant" and the data is immediately available to read.
{{% /alert %}}

{{% alert context="warning" %}}
ACK means the FRAM chip acknowledged each byte. If you see NACK, it means the chip did not acknowledge the command and the write failed. If you see a NACK, check the connections, power supply, and pull-up resistors.
{{% /alert %}}

### Read Byte

![alt text](/images/docs/mb85rc256v/image-3.png)

Reading a byte is a two step process. 
1. Set the location to read with a command to the write address (0xA0). This is the same sequency as writing a byte, but we don't include any data (sometimes called a Dummy Write).
2. Send the read address (0xA1) and read data from the EEPROM.

{{% alert context="info" %}}
Reading from most I2C devices is a two step process. First we set the address pointer, then we read the data. This is a common pattern in I2C devices.
{{% /alert %}}

#### Set address pointer

{{< termfile source="static/snippets/mb85rc256v-read-byte-address.html" >}}

A ```0xa0``` write command is used to set the address pointer to ```0x0009```. This time we won't include any data. The address pointer will be updated, but nothing is written to the FRAM.
- ```[``` - I2C START bit
- ```0xa0``` - I2C address and write bit
- ```0x00 0x09``` - address pointer, high and low bytes, set to 0x0009 (9)
- ```]``` - I2C STOP bit

The address pointer has been set to 0x0009, the location of the data we want to read. This command didn't include a data byte, so nothing was written to the FRAM. 

#### Read Data

{{< termfile source="static/snippets/mb85rc256v-read-byte.html" >}}

Now that the address pointer is set to 0x0009, we can read the data at that location using the I2C read address ```0xa1```.
- ```[``` - I2C START bit
- ```0xa1``` - I2C address and read bit
- ```r``` - Read 1 byte
- ```]``` - I2C STOP bit

The data read from the EEPROM (RX) is ```0x48```, the same value we wrote earlier.

{{% alert context="info" %}}
We used two discrete commands to set the address pointer and read the data. This could also be done in a single sequence by omitting the I2C STOP bit between the two commands. This is called a "repeated start" and is the method shown in the diagram above. The command would look like this: ```[0xa0 0x00 0x09 [ 0xa1 r]```. The I2C STOP bit is not needed between the two commands, but it is required at the end of the transaction.
{{% /alert %}}

## Write & Read Multiple Bytes

EEPROM and flash memory is organized into write pages of 8, 16, or 64 bytes. This means that writes must be aligned to the page size and boundary, and then you wait for the write to complete. 

**FRAM does not have this limitation**! This is a huge advantage that we just learned about at this moment! Writing to FRAM is like writing to SRAM, you can write as much data wherever you want at top speed without juggling around page boundaries. This makes code much simpler!

{{% alert context="danger" %}}
MB85RC256V FRAM doesn't have a write page size like traditional EEPROM and flash memory. 
{{% /alert %}}

### Write Multiple Bytes

![alt text](/images/docs/mb85rc256v/image-5.png)

Writing multiple bytes is similar to writing single byte, we just send more data! Set the address pointer to the location of the first byte to write, and then send as much data as you like. 

{{% alert context="warning" %}}
Note that when the address pointer reaches the end of the 32 Kbyte memory, **it rolls over and starts writing at the beginning (0x0000) of the memory**.
{{% /alert %}}

{{< termfile source="static/snippets/mb85rc256v-write-page.html" >}}

Let's write 32 bytes starting at address 0x0000, the beginning of the memory.

- ```[``` - I2C START bit 
- ```0xa0``` - I2C address and write bit
- ```0x00 0x00``` - set the address pointer to 0x0000 (the beginning of the memory)
- ```0x55:16 0xaa:16``` - Write 0x55 and 0xaa to the FRAM, 16 times each
- ```]``` - I2C STOP bit

{{% alert context="info" %}} 
Remember two big advantages of FRAM:
- No write delay, the data is immediately available to read
- No page size, you can write as much data as you like without worrying about page boundaries
{{% /alert %}}

### Read Multiple Bytes
![alt text](./images/docs/mb85rc256v/image-6.png)

Reading multiple bytes is similar to reading a single byte. First we set the address pointer to the beginning of the page with a write command, then we read the data - only more of it! The last byte read is NACKed by the Bus Pirate automatically to tell the FRAM we're done reading. 

#### Set Address Pointer

{{< termfile source="static/snippets/mb85rc256v-read-page-address.html" >}}

Set the address pointer to the beginning the memory, address 0x0000.
- ```[``` - I2C START bit
- ```0xa0``` - I2C address and write bit
- ```0x00 0x00``` - set the address pointer to 0x0000 (the beginning of the memory)
- ```]``` - I2C STOP bit

#### Read Bytes
{{< termfile source="static/snippets/mb85rc256v-read-page.html" >}}

Read back 32 bytes to verify the data was written.
- ```[``` - I2C START bit
- ```0xa1``` - I2C address and read bit
- ```r:32``` - Read 32 bytes
- ```]``` - I2C STOP bit

The data read from the FRAM (RX) is 16 bytes of 0x55 and 16 bytes of 0xaa. The write was successful!
 
## Read FRAM ID

![alt text](/images/docs/mb85rc256v/image-8.png)

The MB85RC256V has a 3 byte device ID that can be read from the *Reserved Slave ID* (0xf8/0xf9), a second I2C address that is not used for normal operations.

1. I2C START bit - begins an I2C transaction
2. Write to the *Reserved Slave ID* write address (0xf8)
3. Write the I2C device address (0xa0 or 0xa1, doesn't matter)
4. I2C repeated START bit - prepares to read data
5. Write the *Reserved Slave ID* read address (0xf9)
6. Read 3 byte device ID
7. I2C STOP bit - ends the transaction

{{< termfile source="static/snippets/mb85rc256v-read-id.html" >}}

- ```[0xf8 0xa0 [0xf9 r:3]``` - Read the 3 byte device ID from the *Reserved Slave ID* address.

![alt text](/images/docs/mb85rc256v/image-9.png)

The device ID is 0x00A510.
- The upper 12 bits (0x00A) make up the manufacturer ID, Fujitsu.
- The lower 12 bits (0x510) make up the product ID, which includes a 4 bit density code (0x5) and a byte of proprietary info (0x10).

## Get a Bus Pirate


{{% readfile "/_common/_footer/_footer-get.md" %}}

### Community


{{% readfile "/_common/_footer/_footer-community.md" %}}
